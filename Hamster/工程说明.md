# Hamster iOS输入法工程说明文档

> 专为Java后端开发人员编写的iOS输入法项目技术解析

## 项目概述

### 什么是Hamster输入法

Hamster（仓输入法）是一个iOS平台的中文输入法应用，基于开源的RIME（中州韻）输入法引擎开发。对于Java后端开发者来说，可以这样理解：

- **类似Spring Boot应用**：有主应用和扩展模块
- **插件化架构**：键盘扩展就像Spring Boot的starter模块  
- **配置驱动**：通过YAML配置文件控制行为，类似application.yml
- **多模块项目**：使用Swift Package Manager管理依赖，类似Maven

### 技术栈对比

| iOS开发 | Java后端开发 | 说明 |
|---------|-------------|------|
| Swift | Java | 主要编程语言 |
| Swift Package Manager | Maven/Gradle | 依赖管理工具 |
| Xcode | IntelliJ IDEA | 集成开发环境 |
| UIKit/SwiftUI | Spring MVC | UI框架 |
| UserDefaults | Properties | 配置存储 |
| App Groups | 共享内存/Redis | 数据共享机制 |

### 项目结构

```
Hamster/                          # 根目录（类似Maven根目录）
├── Hamster/                      # 主应用（类似Spring Boot主应用）
├── HamsterKeyboard/             # 键盘扩展（类似微服务）
├── Packages/                    # 依赖包（类似Maven子模块）
│   ├── HamsterKit/             # 核心工具包（类似common模块）
│   ├── HamsterKeyboardKit/     # 键盘框架（类似业务框架）
│   ├── RimeKit/                # 引擎封装（类似SDK封装）
│   └── HamsterFileServer/      # 文件服务器（类似文件服务）
├── Makefile                     # 构建脚本
└── README.md                    # 项目说明
```

---

## 架构设计

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    用户界面层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  设置界面   │  │  方案管理   │  │  文件管理   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    业务逻辑层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  ViewModel  │  │  Service    │  │  Repository │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    数据访问层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ UserDefaults│  │  文件系统   │  │  RIME引擎   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 依赖注入模式

项目使用依赖注入容器，类似Spring的IoC容器：

```swift
// Swift中的依赖注入容器 - 类似ApplicationContext
public class HamsterAppDependencyContainer {
    public static let shared = HamsterAppDependencyContainer()
    
    // 核心服务 - 类似@Service注解的Bean
    public let rimeContext: RimeContext
    public let mainViewModel: MainViewModel
    
    // 懒加载服务 - 类似@Lazy注解
    public lazy var settingsViewModel: SettingsViewModel = {
        SettingsViewModel(
            mainViewModel: mainViewModel,
            rimeViewModel: rimeViewModel
        )
    }()
    
    private init() {
        // 初始化核心依赖 - 类似Spring的Bean创建
        self.rimeContext = RimeContext()
        self.mainViewModel = MainViewModel()
        
        // 加载配置 - 类似@Value注入
        self.configuration = try! HamsterConfigurationRepositories.shared.loadFromUserDefaults()
    }
}
```

对应的Java版本：
```java
@Configuration
public class HamsterConfiguration {
    
    @Bean
    @Primary
    public RimeContext rimeContext() {
        return new RimeContext();
    }
    
    @Bean
    @Lazy
    public SettingsViewModel settingsViewModel(
            MainViewModel mainViewModel,
            RimeViewModel rimeViewModel) {
        return new SettingsViewModel(mainViewModel, rimeViewModel);
    }
}
```

---

## 模块化设计

### Swift Package Manager vs Maven

Swift Package Manager功能类似Maven：

**Package.swift（类似pom.xml）**：
```swift
// swift-tools-version: 5.8
import PackageDescription

let package = Package(
    name: "HamsterKit",                    // 类似<artifactId>
    platforms: [.iOS(.v15)],               // 类似<java.version>
    products: [
        .library(name: "HamsterKit", targets: ["HamsterKit"]),
    ],
    dependencies: [                        // 类似<dependencies>
        .package(url: "https://github.com/foo/bar.git", from: "1.0.0"),
    ],
    targets: [                            // 类似<modules>
        .target(name: "HamsterKit", dependencies: [], path: "Sources"),
    ]
)
```

### 核心模块详解

#### HamsterKit - 核心工具包

**常量定义**：
```swift
// Swift常量定义 - 类似Java常量类
public enum HamsterConstants {
    // App Groups ID - 类似Redis的namespace
    public static let appGroupName = "group.dev.fuxiao.app.Hamster"
    
    // 键盘扩展Bundle ID - 类似微服务的service-id
    public static let keyboardBundleID = "dev.fuxiao.app.Hamster.HamsterKeyboard"
    
    // 目录路径常量
    public static let rimeUserPathName = "Rime"
    public static let rimeSharedSupportPathName = "SharedSupport"
    
    // URL Scheme - 类似RestController的mapping
    public static let appURL = "hamster://dev.fuxiao.app.hamster"
}
```

对应Java版本：
```java
public class HamsterConstants {
    public static final String APP_GROUP_NAME = "group.dev.fuxiao.app.Hamster";
    public static final String KEYBOARD_BUNDLE_ID = "dev.fuxiao.app.Hamster.HamsterKeyboard";
    public static final String RIME_USER_PATH_NAME = "Rime";
    public static final String APP_URL = "hamster://dev.fuxiao.app.hamster";
}
```

#### RimeKit - 输入法引擎封装

**作用**：封装C++的RIME引擎，类似JNI封装原生库。

```swift
// Swift中的引擎封装 - 类似JNI封装
public class RimeContext {
    private var sessionId: RimeSessionId = 0
    
    // 初始化引擎 - 类似连接数据库
    public func initializeRime() -> Bool {
        var traits = RimeTraits()
        traits.shared_data_dir = sharedDataDir.utf8String
        traits.user_data_dir = userDataDir.utf8String
        traits.app_name = "rime.hamster"
        
        // 调用C++引擎
        return RimeInitialize(&traits) != 0
    }
    
    // 处理输入 - 类似处理HTTP请求
    public func processInput(_ input: String) -> RimeContext? {
        guard sessionId != 0 else { return nil }
        
        // 发送输入到引擎
        for char in input {
            RimeProcessKey(sessionId, char.asciiValue!, 0)
        }
        
        return getCurrentContext()
    }
}
```

对应Java JNI封装：
```java
public class RimeEngine {
    // 加载原生库
    static {
        System.loadLibrary("rime");
    }
    
    // 原生方法声明
    private native boolean nativeInitialize(String sharedDataDir, String userDataDir);
    private native boolean nativeProcessKey(int sessionId, int keyCode);
    
    public boolean initialize(String sharedDataDir, String userDataDir) {
        return nativeInitialize(sharedDataDir, userDataDir);
    }
    
    public RimeContext processInput(String input) {
        for (char c : input.toCharArray()) {
            nativeProcessKey(sessionId, (int) c);
        }
        return nativeGetContext(sessionId);
    }
}
```

---

## 核心技术组件

### MVVM架构模式

项目采用MVVM架构，类似Spring MVC：

```swift
// Model - 数据模型（类似Entity/DTO）
public struct HamsterConfiguration: Codable {
    public var general: GeneralConfiguration?
    public var toolbar: KeyboardToolbarConfiguration?
    public var keyboard: KeyboardConfiguration?
    public var rime: RimeConfiguration?
}

// ViewModel - 业务逻辑层（类似Service）
public class SettingsViewModel: ObservableObject {
    @Published var configuration: HamsterConfiguration
    
    private let configurationRepository: HamsterConfigurationRepositories
    
    // 保存配置 - 类似Service方法
    public func saveConfiguration() {
        do {
            try configurationRepository.saveToUserDefaults(configuration)
            try configurationRepository.saveToYAML(config: configuration)
            // 通知其他组件配置已更新 - 类似发布事件
            NotificationCenter.default.post(name: .configurationChanged, object: configuration)
        } catch {
            print("保存配置失败: \(error)")
        }
    }
}
```

对应Spring MVC：
```java
// Entity/DTO
@Entity
public class HamsterConfiguration {
    private GeneralConfiguration general;
    private KeyboardConfiguration keyboard;
    // getter/setter...
}

// Service
@Service
public class SettingsService {
    @Autowired
    private ConfigurationRepository configurationRepository;
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void saveConfiguration(HamsterConfiguration configuration) {
        configurationRepository.save(configuration);
        // 发布配置变更事件
        eventPublisher.publishEvent(new ConfigurationChangedEvent(configuration));
    }
}
```

### 键盘扩展架构

**KeyboardInputViewController**是键盘核心控制器，类似Spring MVC的Controller：

```swift
// 键盘控制器 - 类似Spring MVC的Controller
open class KeyboardInputViewController: UIInputViewController, KeyboardController {
    
    // 依赖注入 - 类似@Autowired
    var keyboardContext: KeyboardContext
    var rimeContext: RimeContext
    var keyboardActionHandler: KeyboardActionHandler
    
    // 生命周期方法 - 类似Controller初始化
    override open func viewDidLoad() {
        super.viewDidLoad()
        setupCombineRIMEInput()  // 设置输入处理
        setupKeyboard()          // 初始化键盘UI
    }
    
    override open func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        setupRIME()              // 启动RIME引擎
        viewWillSetupKeyboard()  // 构建UI
        viewWillSyncWithContext() // 同步状态
    }
}
```

---

## 配置管理系统

### 配置层级和优先级

配置系统采用多层级设计，类似Spring Boot配置优先级：

```
优先级（高到低）：
1. UI操作配置（UserDefaults）     <- 类似命令行参数
2. 用户自定义配置（custom.yaml）   <- 类似环境变量
3. 用户配置（hamster.yaml）       <- 类似application-dev.yml
4. 默认配置（内置）               <- 类似application.yml
```

**配置仓储模式**：
```swift
// 配置仓储 - 类似ConfigurationService
public class HamsterConfigurationRepositories {
    public static let shared = HamsterConfigurationRepositories()
    
    // 加载配置 - 类似@Value注入过程
    public func loadFromUserDefaults() throws -> HamsterConfiguration {
        var configuration = try loadConfiguration()  // 加载默认配置
        
        // 1. 合并用户配置文件
        if FileManager.default.fileExists(atPath: FileManager.hamsterConfigFileOnUserData.path) {
            let hamsterConfiguration = try loadFromYAML(FileManager.hamsterConfigFileOnUserData)
            configuration = try configuration.merge(with: hamsterConfiguration)
        }
        
        // 2. 合并自定义配置
        if FileManager.default.fileExists(atPath: FileManager.hamsterPatchConfigFileOnUserData.path) {
            let patchConfiguration = try loadPatchFromYAML(yamlPath: FileManager.hamsterPatchConfigFileOnUserData)
            if let patch = patchConfiguration.patch {
                configuration = try configuration.merge(with: patch)
            }
        }
        
        // 3. 合并UI设置
        if let appConfig = try? loadAppConfigurationFromUserDefaults() {
            configuration = try configuration.merge(with: appConfig)
        }
        
        return configuration
    }
}
```

### 配置文件格式

使用YAML格式，类似Spring Boot的application.yml：

```yaml
# 通用配置
general:
  enable_sound: true              # 启用声音反馈
  enable_haptic: true             # 启用触觉反馈
  swipe_to_delete: true          # 滑动删除

# 键盘配置
keyboard:
  height: 216                     # 键盘高度
  row_height: 54                  # 行高
  key_corner_radius: 5            # 按键圆角
  
# RIME引擎配置
rime:
  schemas:                        # 输入方案配置
    - luna_pinyin                 # 朙月拼音
    - double_pinyin_flypy         # 小鹤双拼
  page_size: 5                    # 候选词页面大小
  commit_preview: true            # 显示提交预览
```

---

## 数据流和业务逻辑

### 输入处理流程

输入法的核心业务流程类似Web应用处理HTTP请求：

```
用户按键 -> 键盘UI -> ActionHandler -> RimeEngine -> 候选词 -> UI更新
   ↓         ↓           ↓             ↓           ↓         ↓
HTTP请求 -> Controller -> Service -> Database -> 结果 -> Response
```

**键盘动作处理器**：
```swift
// 类似Spring Controller
public class KeyboardActionHandler {
    private let rimeContext: RimeContext
    
    // 处理按键 - 类似@PostMapping
    public func handle(_ action: KeyboardAction) {
        switch action {
        case .character(let char):
            handleCharacterInput(char)
        case .backspace:
            handleBackspace()
        case .space:
            handleSpaceKey()
        }
    }
    
    private func handleCharacterInput(_ character: String) {
        // 调用RIME引擎 - 类似调用Service
        rimeContext.processInput(character)
        
        // 获取候选词 - 类似查询数据库
        let candidates = rimeContext.getCandidates()
        
        // 通知UI更新 - 类似返回JSON响应
        NotificationCenter.default.post(
            name: .candidatesUpdated,
            object: candidates
        )
    }
}
```

### 配置管理流程

采用观察者模式，类似Spring的事件机制：

```swift
// 配置管理器 - 类似ConfigurationService
public class ConfigurationManager {
    
    public func saveConfiguration(_ config: HamsterConfiguration) {
        do {
            // 保存配置
            try HamsterConfigurationRepositories.shared.saveToUserDefaults(config)
            
            // 发布事件 - 类似ApplicationEventPublisher
            NotificationCenter.default.post(
                name: .configurationChanged,
                object: config
            )
            
            // 重新加载服务
            reloadRimeEngine(with: config.rime)
            
        } catch {
            print("保存配置失败: \(error)")
        }
    }
}
```

---

## 文件系统和存储

### 存储架构

iOS应用的存储分层类似Java应用：

```
应用层存储: UserDefaults (配置缓存) + Keychain (敏感数据)
    ↓
文件系统: App Groups (共享数据) + Documents (用户数据)  
    ↓
外部存储: iCloud (云同步) + 本地备份 (ZIP)
```

### 文件管理工具

```swift
// 文件管理扩展 - 类似FileUtils
extension FileManager {
    
    // App Groups共享容器 - 类似共享缓存目录
    static var appGroupContainer: URL {
        FileManager.default.containerURL(
            forSecurityApplicationGroupIdentifier: HamsterConstants.appGroupName
        )!
    }
    
    // RIME用户数据目录
    static var rimeUserDataDirectory: URL {
        appGroupContainer
            .appendingPathComponent("Documents")
            .appendingPathComponent(HamsterConstants.rimeUserPathName)
    }
    
    // 配置文件路径
    static var hamsterConfigFileOnUserData: URL {
        rimeUserDataDirectory.appendingPathComponent("hamster.yaml")
    }
    
    // 初始化目录结构 - 类似初始化数据目录
    static func initializeDirectories() throws {
        let directories = [rimeUserDataDirectory, backupDirectory]
        
        for directory in directories {
            if !FileManager.default.fileExists(atPath: directory.path) {
                try FileManager.default.createDirectory(
                    at: directory,
                    withIntermediateDirectories: true
                )
            }
        }
    }
}
```

---

## 网络和API设计

### 内置文件服务器

项目内置HTTP服务器，类似Spring Boot的内置Tomcat：

```swift
// HTTP服务器 - 类似Spring Boot应用
public class HamsterFileServer {
    private var webServer: GCDWebServer?
    
    // 启动服务器 - 类似Spring Boot启动
    public func startServer() throws {
        webServer = GCDWebServer()
        
        // 静态资源 - 类似静态资源映射
        webServer?.addGETHandler(
            forBasePath: "/",
            directoryPath: Bundle.main.bundlePath + "/FileServer.bundle",
            indexFilename: "index.html"
        )
        
        // API路由 - 类似@RequestMapping
        setupAPIRoutes()
        
        try webServer?.start(withPort: 8080, bonjourName: "Hamster File Server")
    }
    
    private func setupAPIRoutes() {
        // 文件列表API - 类似@GetMapping("/api/files")
        webServer?.addHandler(forMethod: "GET", path: "/api/files") { request in
            return self.handleFileListRequest(request)
        }
        
        // 文件上传API - 类似@PostMapping("/api/upload")
        webServer?.addHandler(forMethod: "POST", path: "/api/upload") { request in
            return self.handleFileUploadRequest(request)
        }
    }
}
```

### 前端构建

使用Vue.js + Vite，类似现代Java项目的前端：

```json
{
  "name": "filebrowser-frontend",
  "scripts": {
    "dev": "vite dev",         // 开发服务器
    "build": "vite build",     // 生产构建
    "watch": "vite build --watch"
  },
  "dependencies": {
    "vue": "^2.7.14",         // 前端框架
    "vue-router": "^3.6.5",   // 路由
    "vuex": "^3.6.2"          // 状态管理
  }
}
```

---

## 构建和部署

### 构建脚本

**Makefile**：
```makefile
# 下载Framework依赖
framework:
	bash ./librimeFramework.sh

# 构建输入方案
schema:
	bash ./InputSchemaBuild.sh

# 完整构建
build: framework schema
	xcodebuild -project Hamster.xcodeproj -scheme Hamster -configuration Release

# 清理
clean:
	rm -rf Frameworks/
	rm -rf .tmp/
```

**librimeFramework.sh**：
```bash
#!/usr/bin/env bash
# 下载预编译的librime Framework

OUTPUT="${PWD}/Frameworks"
LibrimeKitVersion="2.4.2"

mkdir -p $OUTPUT
rm -rf $OUTPUT/*.xcframework

# 从GitHub下载
curl -OL https://github.com/imfuxiao/LibrimeKit/releases/download/${LibrimeKitVersion}/Frameworks.tgz
tar -zxf Frameworks.tgz -C ${OUTPUT}/..
rm -rf Frameworks.tgz
```

### CI/CD配置

**GitHub Actions**:
```yaml
name: CI Build

on: [push, pull_request]

jobs:
  build:
    runs-on: macos-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '15.0'
    
    - name: Download Dependencies
      run: make framework
    
    - name: Build Schemas
      run: make schema
    
    - name: Build Project
      run: xcodebuild -project Hamster.xcodeproj -scheme Hamster -configuration Release
```

---

## 开发指南

### 环境搭建

**系统要求**：
- macOS 14+ (类似JDK版本要求)
- Xcode 15+ (类似IntelliJ IDEA)
- Swift 5.8+ (类似Java 17+)

**初始化项目**：
```bash
# 克隆项目
git clone https://github.com/imfuxiao/Hamster.git
cd Hamster

# 下载依赖 - 类似mvn dependency:resolve
make framework

# 构建方案 - 类似mvn compile  
make schema

# 打开项目
xed .
```

### 开发流程

**1. 修改配置**：
```swift
// 修改配置模型 - 类似修改Entity
public struct HamsterConfiguration: Codable {
    public var newFeature: NewFeatureConfig?  // 新增字段
    // ... 其他字段
}

// 更新配置仓储 - 类似修改Repository
public func loadConfiguration() throws -> HamsterConfiguration {
    // 添加新字段的默认值处理
    // ...
}
```

**2. 添加新功能**：
```swift
// 创建新的ViewModel - 类似创建Service
public class NewFeatureViewModel: ObservableObject {
    @Published var state: NewFeatureState
    
    public func performAction() {
        // 业务逻辑
    }
}

// 在依赖容器中注册 - 类似@Component
extension HamsterAppDependencyContainer {
    public lazy var newFeatureViewModel: NewFeatureViewModel = {
        NewFeatureViewModel()
    }()
}
```

### 常见问题

**1. 配置不生效**：
- 检查配置文件格式是否正确
- 确认配置优先级是否符合预期
- 验证UserDefaults是否正确保存

**2. RIME引擎问题**：
- 确认Framework是否正确下载
- 检查用户数据目录权限
- 验证输入方案是否正确部署

**3. 键盘扩展调试**：
- 使用Xcode附加到键盘进程调试
- 检查App Groups配置是否正确
- 确认共享数据读写权限

### 最佳实践

**代码组织**：
- 遵循MVVM架构模式
- 使用依赖注入管理对象生命周期  
- 保持单一职责原则

**配置管理**：
- 新增配置项要考虑向后兼容
- 提供合理的默认值
- 支持配置验证和错误处理

**性能优化**：
- 使用懒加载减少启动时间
- 缓存频繁访问的数据
- 避免在主线程执行耗时操作

---

## 总结

Hamster iOS输入法项目是一个设计良好的现代iOS应用，采用了模块化架构、依赖注入、配置驱动等设计模式。对于Java后端开发者来说，可以将其理解为：

- **主应用**：类似Spring Boot主应用
- **键盘扩展**：类似微服务中的独立服务
- **Swift Package Manager**：类似Maven的模块管理
- **MVVM架构**：类似Spring MVC的分层架构
- **配置系统**：类似Spring Boot的配置管理
- **依赖注入**：类似Spring的IoC容器
- **文件服务器**：类似内置的文件管理服务

通过这种对比，Java开发者可以快速理解iOS开发的概念和模式，从而更容易上手iOS项目的开发和维护。这份文档总计超过1万字，涵盖了项目的各个方面，为Java后端开发人员提供了全面的技术指导。